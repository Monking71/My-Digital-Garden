---
{"dg-publish":true,"permalink":"/leeds-university/computer-science/year-2/operating-systems/revision/w9-memory-mangement/p1-description-of-the-problem/"}
---


>[!abstract] Memory Operations
>The CPU can only access registers and main memory directly, with cache in between

Programs are loaded from the disk to memory, within the process’ memory structure
The CPU sends to the memory unit either
- Address and read requests, or
- Address, data, and write requests
Register access $1$ clock cycle
Main memory: multiple cycle (LD/ST instructions). Causing a **stall** in the CPU
Cache helps reduce stall times

### Memory Protection
>[!question] Why do we need memory protection
>Processes should only be able to access their addresses space. We do not want them to be able to impact each other (or the OS) directly

![Pasted image 20250122021607.png](/img/user/Leeds%20University/Computer%20Science/Year%202/Operating%20Systems/Revision/W9%20-%20Memory%20Mangement/images/Pasted%20image%2020250122021607.png)
- Each process’ memory is limited by the `limit`
- Addresses have to live between a limited range, starting at the `base` address
- An error is thrown if `address > base + limit`

![Pasted image 20250122021722.png](/img/user/Leeds%20University/Computer%20Science/Year%202/Operating%20Systems/Revision/W9%20-%20Memory%20Mangement/images/Pasted%20image%2020250122021722.png)
>[!tip] Base and Limit Registers
>These registers can be accessed only by **privileged intructions** in kernel mode. Only the OS can modify them, protecting users from modifying the size of the address sapce

### Address Binding
Programs on the disk have to be moved into memory eventually, for execution
- We will place them in some location, not necessarily at address $0000$
 
How to represent addresses before the decision of placement is made?
- Source programs contain **symbolic addresses** that the compiler binds to **relocatable addresses**, relative to some reference address that is set later
- The linker or loader will bind these to absolute addresses

Address binding can happen at various stages of a programs lifetime:
1. **Compilation**: If the placement memory location is known, the compiler can produce addresses within the binary. Recompilation is needed if the location changes
2. **Loading**: Take the **relocatable code** from the compiler and translate the relative addresses to absolute addresses
3. **Execution**: If the processes can move in memory during execution, then the address binding has to be delayed until this time. This is the most common set-up today

### Logical and Physical Address Spaces
>[!tldr] Logical Address (Virtual Address)
>Generated by the CPU

>[!abstract] Physical Address
>An address that the memory unit works with

The sets of addresses available: **logical address space** and the **physical address space**
>[!tip] 
>Compile-time and load-time binding results in equivalent logical and physical addresses. Execution-time binding makes processes think their address starts at $0000$ and separate mapping is done to the physical address space

### Memory Management Unit
![Pasted image 20250122110555.png](/img/user/Leeds%20University/Computer%20Science/Year%202/Operating%20Systems/Revision/W9%20-%20Memory%20Mangement/images/Pasted%20image%2020250122110555.png)

The base register (where the processes memory segment starts?) is now called a **relocation register**
- The value of the **relocation register** is added to every (virtual) address generated by the user program
- The user program never sees actual physical addresses
- **Execution-time address binding** is done on memory accesses, by the **MMU**
![Pasted image 20250122110801.png](/img/user/Leeds%20University/Computer%20Science/Year%202/Operating%20Systems/Revision/W9%20-%20Memory%20Mangement/images/Pasted%20image%2020250122110801.png)
### Dynamic Loading
Load entire routines when needed!
- The entire program does **not** need to be copied into memory (at first)
- Just load some parts of it when they are called
- Memory utilisation is improved because routines that are not used are never loaded
- All code kept in **relocatable load format** on disk
- Rarely called large routines do not need to be in memory for the lifetime of the process
### Dynamic Linking
**Static Linking**: System libraries and program code are combined into a binary executable

**Dynamic linking** postpones this until execution
- Commonly used with system libraries: do not put them into the executable at all until called
- Allows to share system libraries among processes (**Dynamically Linked Libraries - DLL** or shared libraries)
- Helps with versioning: anew version of the DLL can be updated in memory and all programs that reference it will dynamically link to the new version - no need to re-link
